# Prompt Complet pour Atelier Enligne

## ğŸ¯ Vision du Projet

**Atelier Enligne** est une plateforme web de personnalisation et d'impression de produits physiques avec visualisation 3D en temps rÃ©el. La plateforme permet aux utilisateurs de crÃ©er des designs personnalisÃ©s, de les visualiser sur des produits 3D rÃ©alistes, de passer commande, et mÃªme de revendre leurs crÃ©ations via une boutique intÃ©grÃ©e.

### Objectif Business
- Capter des clients via rÃ©seaux sociaux (Facebook, Instagram, etc.)
- Les diriger vers la plateforme pour crÃ©er leurs produits personnalisÃ©s
- Offrir une expÃ©rience de crÃ©ation fluide et professionnelle
- Permettre aux utilisateurs de devenir revendeurs (marketplace intÃ©grÃ©e)

---

## ğŸ—ï¸ Architecture Technique

### Stack Technologique Principal

```
Frontend:
- React 18+ avec TypeScript
- Vite (build tool - rapide et moderne)
- React Router v6 (navigation)
- Tailwind CSS (styling responsive)
- Zustand (state management - simple et performant)

3D Engine:
- Babylon.js (rendu 3D principal)
- @babylonjs/core
- @babylonjs/loaders
- @babylonjs/materials

Manipulation 2D/Design:
- Fabric.js (manipulation canvas 2D avant application 3D)
- react-dropzone (upload de fichiers)
- react-color (color picker)

Storage:
- localStorage/sessionStorage (phase 1)
- Architecture prÃªte pour Supabase (phase 2)

Utilitaires:
- axios (requÃªtes HTTP)
- date-fns (manipulation dates)
- react-hot-toast (notifications)
- framer-motion (animations fluides)
- react-share (partage rÃ©seaux sociaux)
- html2canvas (capture screenshots pour partage)
```

### Structure du Projet

```
atelier-enligne/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ models/           # ModÃ¨les 3D (.glb, .babylon)
â”‚   â”œâ”€â”€ textures/         # Textures de base
â”‚   â””â”€â”€ assets/           # Images, icÃ´nes
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Navbar.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Modal.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Loader.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Toast.tsx
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginForm.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterForm.tsx
â”‚   â”‚   â”‚   â””â”€â”€ GuestPrompt.tsx
â”‚   â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductGrid.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductFilter.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ProductDetail.tsx
â”‚   â”‚   â”œâ”€â”€ atelier/
â”‚   â”‚   â”‚   â”œâ”€â”€ AtelierCanvas.tsx      # Composant principal
â”‚   â”‚   â”‚   â”œâ”€â”€ Scene3D.tsx            # Scene Babylon.js
â”‚   â”‚   â”‚   â”œâ”€â”€ DesignControls.tsx     # ContrÃ´les de design
â”‚   â”‚   â”‚   â”œâ”€â”€ ToolPanel.tsx          # Panneau d'outils
â”‚   â”‚   â”‚   â”œâ”€â”€ LayerPanel.tsx         # Gestion des calques
â”‚   â”‚   â”‚   â”œâ”€â”€ TextTool.tsx           # Ajout de texte
â”‚   â”‚   â”‚   â”œâ”€â”€ ImageUploader.tsx      # Upload logo
â”‚   â”‚   â”‚   â”œâ”€â”€ ColorPicker.tsx        # SÃ©lection couleurs
â”‚   â”‚   â”‚   â”œâ”€â”€ ViewControls.tsx       # Rotation/zoom 3D
â”‚   â”‚   â”‚   â””â”€â”€ SavePanel.tsx          # Sauvegarde/export
â”‚   â”‚   â”œâ”€â”€ shop/
â”‚   â”‚   â”‚   â”œâ”€â”€ MyShop.tsx             # Boutique personnelle
â”‚   â”‚   â”‚   â”œâ”€â”€ ShopSettings.tsx       # Configuration boutique
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductListing.tsx     # Liste produits boutique
â”‚   â”‚   â”‚   â”œâ”€â”€ PublicShop.tsx         # Vue publique boutique
â”‚   â”‚   â”‚   â””â”€â”€ ShopStats.tsx          # Statistiques ventes
â”‚   â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderDetail.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderTracking.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Checkout.tsx
â”‚   â”‚   â”œâ”€â”€ social/
â”‚   â”‚   â”‚   â”œâ”€â”€ ShareButtons.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ CommentSection.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ LikeButton.tsx
â”‚   â”‚   â”‚   â””â”€â”€ SocialPreview.tsx
â”‚   â”‚   â””â”€â”€ gallery/
â”‚   â”‚       â”œâ”€â”€ DesignGallery.tsx
â”‚   â”‚       â”œâ”€â”€ GalleryCard.tsx
â”‚   â”‚       â””â”€â”€ GalleryFilters.tsx
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Home.tsx
â”‚   â”‚   â”œâ”€â”€ Products.tsx
â”‚   â”‚   â”œâ”€â”€ Atelier.tsx              # PAGE PRINCIPALE
â”‚   â”‚   â”œâ”€â”€ MyDesigns.tsx
â”‚   â”‚   â”œâ”€â”€ MyOrders.tsx
â”‚   â”‚   â”œâ”€â”€ MyShop.tsx
â”‚   â”‚   â”œâ”€â”€ Shop.tsx                 # Marketplace
â”‚   â”‚   â”œâ”€â”€ ShopDetail.tsx           # Boutique d'un utilisateur
â”‚   â”‚   â”œâ”€â”€ DesignDetail.tsx         # DÃ©tail d'une crÃ©ation
â”‚   â”‚   â”œâ”€â”€ Profile.tsx
â”‚   â”‚   â””â”€â”€ NotFound.tsx
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”‚   â”œâ”€â”€ designStore.ts
â”‚   â”‚   â”œâ”€â”€ productStore.ts
â”‚   â”‚   â”œâ”€â”€ cartStore.ts
â”‚   â”‚   â”œâ”€â”€ shopStore.ts
â”‚   â”‚   â””â”€â”€ uiStore.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ storage.service.ts       # Abstraction localStorage/Supabase
â”‚   â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”‚   â”œâ”€â”€ design.service.ts
â”‚   â”‚   â”œâ”€â”€ product.service.ts
â”‚   â”‚   â”œâ”€â”€ order.service.ts
â”‚   â”‚   â”œâ”€â”€ shop.service.ts
â”‚   â”‚   â”œâ”€â”€ babylon.service.ts       # Helpers Babylon.js
â”‚   â”‚   â””â”€â”€ export.service.ts        # Export images/3D
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”œâ”€â”€ useDesign.ts
â”‚   â”‚   â”œâ”€â”€ use3DScene.ts
â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â””â”€â”€ useAutoSave.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ constants.ts
â”‚   â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ imageProcessor.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ user.types.ts
â”‚   â”‚   â”œâ”€â”€ design.types.ts
â”‚   â”‚   â”œâ”€â”€ product.types.ts
â”‚   â”‚   â”œâ”€â”€ order.types.ts
â”‚   â”‚   â””â”€â”€ shop.types.ts
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â””â”€â”€ globals.css
â”‚   â”œâ”€â”€ App.tsx
â”‚   â””â”€â”€ main.tsx
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ vite.config.ts
â””â”€â”€ README.md
```

---

## ğŸ“‹ SpÃ©cifications DÃ©taillÃ©es par Module

### 1. Module d'Authentification

#### FonctionnalitÃ©s
- **Mode InvitÃ©**: Permettre la navigation et crÃ©ation sans compte
  - Stocker session temporaire dans sessionStorage
  - Promouvoir inscription avant finalisation commande
  - RÃ©cupÃ©rer les crÃ©ations aprÃ¨s inscription

- **Inscription**:
  - Email + mot de passe
  - Nom + prÃ©nom
  - Nom de boutique (optionnel, peut Ãªtre ajoutÃ© plus tard)
  - Validation cÃ´tÃ© client (regex email, mdp min 8 caractÃ¨res)

- **Connexion**:
  - Email + mot de passe
  - Option "Se souvenir de moi" (localStorage)
  - Lien "Mot de passe oubliÃ©" (prÃªt pour implÃ©mentation future)

- **Ã‰tat d'authentification**:
  - Persister dans localStorage: `{ userId, email, name, shopName, token, expiresAt }`
  - VÃ©rifier au chargement de l'app
  - Auto-refresh si token valide

#### Interface localStorage (Phase 1)
```typescript
interface User {
  id: string;
  email: string;
  name: string;
  shopName?: string;
  createdAt: string;
  isGuest: boolean;
}

// Stockage:
localStorage.setItem('auth_user', JSON.stringify(user));
localStorage.setItem('auth_token', token);
```

#### Architecture Supabase-ready
```typescript
// service/auth.service.ts
class AuthService {
  // Phase 1: localStorage
  async login(email: string, password: string) {
    // Logique localStorage
  }
  
  // Phase 2: Remplacer par
  // return supabase.auth.signInWithPassword({ email, password })
}
```

---

### 2. Module SÃ©lection de Produits

#### CatÃ©gories de Produits

```typescript
enum ProductCategory {
  CLOTHING = 'VÃªtements',
  ACCESSORIES = 'Accessoires',
  HOME = 'Maison',
  CUSTOM = 'PersonnalisÃ©'
}

interface Product {
  id: string;
  name: string;
  category: ProductCategory;
  basePrice: number;
  modelPath: string;        // Chemin vers modÃ¨le 3D
  textureAreas: TextureArea[];  // Zones personnalisables
  availableColors: string[];
  sizes?: string[];
  description: string;
  previewImage: string;
}

interface TextureArea {
  id: string;
  name: string;              // "Face avant", "Dos", etc.
  uvMapping: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  maxDesignSize: {
    width: number;
    height: number;
  };
}
```

#### Produits Ã  ImplÃ©menter

**VÃªtements**:
- Sweat Ã  capuche (hoodie)
  - Zones: Face avant, dos, manches, capuche
  - Tailles: XS, S, M, L, XL, XXL
  - Couleurs: 10+ options
  
- T-shirt
  - Zones: Face avant, dos
  - Tailles: XS, S, M, L, XL, XXL
  - Couleurs: 15+ options

- Ã‰charpe
  - Zone unique: Surface totale
  - Taille standard
  - Couleurs: 8+ options

- Casquette
  - Zones: Face avant, cÃ´tÃ©s
  - Taille ajustable
  - Couleurs: 10+ options

**Accessoires**:
- Mug/Tasse
  - Zone: Surface cylindrique
  - CapacitÃ©: 330ml, 450ml
  - Couleurs: Blanc, noir, colorÃ©

- Sac tote
  - Zones: Face avant, dos
  - Taille standard
  - Couleurs: Naturel, noir, couleurs

- Coussin
  - Zones: Recto, verso
  - Tailles: 40x40, 50x50
  - Couleurs: Blanc + options

**Maison**:
- Poster
  - Format: A4, A3, A2, A1
  - Finition: Mat, brillant, canvas

- Stickers
  - Formes: Rond, carrÃ©, custom
  - Tailles: Small, Medium, Large

#### Interface Utilisateur

**Page Produits**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Filtres]  [CatÃ©gories]  [Recherche]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”          â”‚
â”‚  â”‚ ğŸ½ â”‚ â”‚ ğŸ‘• â”‚ â”‚ ğŸ§£ â”‚ â”‚ ğŸ§¢ â”‚          â”‚
â”‚  â”‚ 15â‚¬â”‚ â”‚ 12â‚¬â”‚ â”‚ 8â‚¬ â”‚ â”‚ 10â‚¬â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜          â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”          â”‚
â”‚  â”‚ â˜• â”‚ â”‚ ğŸ›ï¸ â”‚ â”‚ ğŸ–¼ï¸ â”‚ â”‚ ğŸ¨ â”‚          â”‚
â”‚  â”‚ 9â‚¬ â”‚ â”‚ 11â‚¬â”‚ â”‚ 15â‚¬â”‚ â”‚ 5â‚¬ â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜          â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**FonctionnalitÃ©s**:
- Grille responsive (1, 2, 3, 4 colonnes selon device)
- AperÃ§u 3D au survol (mini rotation)
- Filtres: Prix, catÃ©gorie, couleur disponible
- Tri: Prix, popularitÃ©, nouveautÃ©
- Quick view modal avec dÃ©tails
- Bouton "Personnaliser" â†’ Atelier

---

### 3. Module Atelier (CÅ’UR DE L'APPLICATION)

#### Vue d'Ensemble

L'**Atelier** est le module le plus critique. C'est ici que l'utilisateur crÃ©e son design. L'expÃ©rience doit Ãªtre:
- **Fluide**: 60 FPS minimum
- **Intuitive**: Drag & drop naturel
- **Sans erreur**: Gestion robuste des edge cases
- **Professionnelle**: Rendu 3D rÃ©aliste

#### Layout de l'Atelier

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Logo] Atelier Enligne    [Sauvegarder] [Partager] [âŒ]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             â”‚                             â”‚               â”‚
â”‚  PANNEAU    â”‚       VUE 3D               â”‚   PROPRIÃ‰TÃ‰S  â”‚
â”‚  D'OUTILS   â”‚                             â”‚               â”‚
â”‚             â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  ğŸ“ Import  â”‚    â”‚                 â”‚      â”‚  â”‚ Positionâ”‚  â”‚
â”‚  ğŸ“ Texte   â”‚    â”‚                 â”‚      â”‚  â”‚ Taille  â”‚  â”‚
â”‚  ğŸ¨ Couleur â”‚    â”‚   [PRODUIT 3D]  â”‚      â”‚  â”‚ Rotationâ”‚  â”‚
â”‚  ğŸ–¼ï¸ Clipart â”‚    â”‚                 â”‚      â”‚  â”‚ OpacitÃ© â”‚  â”‚
â”‚  âš™ï¸ Filtres â”‚    â”‚                 â”‚      â”‚  â”‚ Couleur â”‚  â”‚
â”‚             â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚             â”‚                             â”‚               â”‚
â”‚  CALQUES    â”‚   [< ] [Reset] [ >]         â”‚  [Supprimer]  â”‚
â”‚  Layer 1 ğŸ‘ï¸ â”‚   [Zoom -] [+]             â”‚  [Dupliquer]  â”‚
â”‚  Layer 2 ğŸ‘ï¸ â”‚                             â”‚  [Avant/Arr]  â”‚
â”‚             â”‚                             â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  [Face] [Dos] [CÃ´tÃ© G] [CÃ´tÃ© D]  | Produit: T-shirt Blancâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ImplÃ©mentation Babylon.js

**Initialisation de la ScÃ¨ne**:
```typescript
// components/atelier/Scene3D.tsx
import * as BABYLON from '@babylonjs/core';
import { useEffect, useRef } from 'react';

const Scene3D = ({ productModel, design, onSceneReady }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const engineRef = useRef<BABYLON.Engine | null>(null);
  const sceneRef = useRef<BABYLON.Scene | null>(null);

  useEffect(() => {
    if (!canvasRef.current) return;

    // CrÃ©er Engine
    const engine = new BABYLON.Engine(canvasRef.current, true, {
      preserveDrawingBuffer: true,
      stencil: true,
      antialias: true
    });
    engineRef.current = engine;

    // CrÃ©er Scene
    const scene = new BABYLON.Scene(engine);
    sceneRef.current = scene;

    // Configuration de base
    scene.clearColor = new BABYLON.Color4(0.95, 0.95, 0.95, 1);

    // CamÃ©ra Arc Rotate (rotation autour du produit)
    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      Math.PI / 2,
      Math.PI / 3,
      5,
      BABYLON.Vector3.Zero(),
      scene
    );
    camera.attachControl(canvasRef.current, true);
    camera.lowerRadiusLimit = 2;
    camera.upperRadiusLimit = 10;
    camera.wheelPrecision = 50;

    // LumiÃ¨res pour rendu rÃ©aliste
    const hemiLight = new BABYLON.HemisphericLight(
      "hemiLight",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    hemiLight.intensity = 0.7;

    const dirLight = new BABYLON.DirectionalLight(
      "dirLight",
      new BABYLON.Vector3(-1, -2, -1),
      scene
    );
    dirLight.intensity = 0.5;

    // LumiÃ¨re pour reflets
    const spotLight = new BABYLON.SpotLight(
      "spotLight",
      new BABYLON.Vector3(0, 3, 0),
      new BABYLON.Vector3(0, -1, 0),
      Math.PI / 3,
      2,
      scene
    );
    spotLight.intensity = 0.3;

    // Charger le modÃ¨le 3D du produit
    BABYLON.SceneLoader.ImportMesh(
      "",
      "/models/",
      productModel.modelPath,
      scene,
      (meshes) => {
        const product = meshes[0];
        
        // CrÃ©er matÃ©riau PBR pour rÃ©alisme
        const pbr = new BABYLON.PBRMaterial("productMaterial", scene);
        pbr.albedoColor = new BABYLON.Color3(1, 1, 1);
        pbr.metallic = 0.0;
        pbr.roughness = 0.8;
        
        // Appliquer Ã  toutes les parties du produit
        meshes.forEach(mesh => {
          if (mesh.material) {
            mesh.material = pbr;
          }
        });

        // PrÃªt Ã  appliquer design
        onSceneReady(scene, product);
      }
    );

    // Render loop
    engine.runRenderLoop(() => {
      scene.render();
    });

    // Resize handler
    const handleResize = () => {
      engine.resize();
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      scene.dispose();
      engine.dispose();
    };
  }, [productModel]);

  return (
    <canvas
      ref={canvasRef}
      style={{ width: '100%', height: '100%', touchAction: 'none' }}
    />
  );
};
```

**Application de Design sur Texture**:
```typescript
// services/babylon.service.ts
export class BabylonDesignService {
  
  // Appliquer un design (logo/image) sur le produit 3D
  static applyDesignToMesh(
    mesh: BABYLON.Mesh,
    designImage: HTMLImageElement,
    textureArea: TextureArea,
    scene: BABYLON.Scene
  ) {
    // CrÃ©er un canvas 2D pour composer la texture
    const canvas = document.createElement('canvas');
    canvas.width = 2048;  // Haute rÃ©solution
    canvas.height = 2048;
    const ctx = canvas.getContext('2d')!;

    // Fond de la couleur du produit
    ctx.fillStyle = '#FFFFFF';  // ou couleur choisie
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculer position et taille du design
    const { x, y, width, height } = this.calculateDesignPosition(
      designImage,
      textureArea,
      canvas.width,
      canvas.height
    );

    // Dessiner le design
    ctx.drawImage(designImage, x, y, width, height);

    // CrÃ©er texture Babylon.js depuis canvas
    const texture = new BABYLON.Texture(
      canvas.toDataURL(),
      scene,
      false,
      false,
      BABYLON.Texture.TRILINEAR_SAMPLINGMODE
    );

    // Appliquer au matÃ©riau du mesh
    if (mesh.material instanceof BABYLON.PBRMaterial) {
      mesh.material.albedoTexture = texture;
    }

    return texture;
  }

  // Calculer position du design sur texture UV
  static calculateDesignPosition(
    image: HTMLImageElement,
    area: TextureArea,
    canvasWidth: number,
    canvasHeight: number
  ) {
    const { uvMapping, maxDesignSize } = area;
    
    // Convertir coordonnÃ©es UV (0-1) en pixels
    const areaX = uvMapping.x * canvasWidth;
    const areaY = uvMapping.y * canvasHeight;
    const areaWidth = uvMapping.width * canvasWidth;
    const areaHeight = uvMapping.height * canvasHeight;

    // Calculer ratio pour fit dans la zone
    const scaleX = areaWidth / image.width;
    const scaleY = areaHeight / image.height;
    const scale = Math.min(scaleX, scaleY, 1);

    const width = image.width * scale;
    const height = image.height * scale;
    
    // Centrer dans la zone
    const x = areaX + (areaWidth - width) / 2;
    const y = areaY + (areaHeight - height) / 2;

    return { x, y, width, height };
  }

  // Mettre Ã  jour texture en temps rÃ©el
  static updateTexture(
    texture: BABYLON.DynamicTexture,
    design: DesignElement[]
  ) {
    const ctx = texture.getContext();
    
    // Clear
    ctx.clearRect(0, 0, texture.getSize().width, texture.getSize().height);
    
    // Dessiner chaque Ã©lÃ©ment du design
    design.forEach(element => {
      if (element.type === 'image') {
        ctx.drawImage(
          element.image,
          element.position.x,
          element.position.y,
          element.size.width,
          element.size.height
        );
      } else if (element.type === 'text') {
        ctx.font = `${element.fontSize}px ${element.fontFamily}`;
        ctx.fillStyle = element.color;
        ctx.fillText(
          element.text,
          element.position.x,
          element.position.y
        );
      }
    });

    texture.update();
  }
}
```

#### Gestion des Interactions

**Drag & Drop pour positionner le design**:
```typescript
// hooks/use3DInteraction.ts
export const use3DInteraction = (scene, mesh, onUpdate) => {
  useEffect(() => {
    if (!scene || !mesh) return;

    let isDragging = false;
    let startPoint: BABYLON.Vector3 | null = null;

    const onPointerDown = (evt) => {
      if (evt.button !== 0) return;
      
      const pickResult = scene.pick(scene.pointerX, scene.pointerY);
      if (pickResult.hit && pickResult.pickedMesh === mesh) {
        isDragging = true;
        startPoint = pickResult.pickedPoint;
      }
    };

    const onPointerMove = (evt) => {
      if (!isDragging) return;

      const pickResult = scene.pick(scene.pointerX, scene.pointerY);
      if (pickResult.hit) {
        const delta = pickResult.pickedPoint.subtract(startPoint);
        
        // Mettre Ã  jour position du design
        onUpdate({
          type: 'position',
          delta: { x: delta.x, y: delta.y }
        });
        
        startPoint = pickResult.pickedPoint;
      }
    };

    const onPointerUp = () => {
      isDragging = false;
      startPoint = null;
    };

    scene.onPointerDown = onPointerDown;
    scene.onPointerMove = onPointerMove;
    scene.onPointerUp = onPointerUp;

    return () => {
      scene.onPointerDown = null;
      scene.onPointerMove = null;
      scene.onPointerUp = null;
    };
  }, [scene, mesh, onUpdate]);
};
```

#### Panneau d'Outils

**1. Import de Logo/Image**:
```typescript
// components/atelier/ImageUploader.tsx
import { useDropzone } from 'react-dropzone';

const ImageUploader = ({ onImageUpload }) => {
  const { getRootProps, getInputProps } = useDropzone({
    accept: {
      'image/png': ['.png'],
      'image/jpeg': ['.jpg', '.jpeg'],
      'image/svg+xml': ['.svg']
    },
    maxSize: 2 * 1024 * 1024, // 2MB
    onDrop: async (acceptedFiles) => {
      const file = acceptedFiles[0];
      if (!file) return;

      // Compresser l'image si nÃ©cessaire
      const compressed = await compressImage(file);
      
      // CrÃ©er HTMLImageElement
      const img = new Image();
      img.src = URL.createObjectURL(compressed);
      img.onload = () => {
        onImageUpload({
          id: generateId(),
          type: 'image',
          image: img,
          originalFile: file,
          position: { x: 0, y: 0 },
          size: { width: img.width, height: img.height },
          rotation: 0,
          opacity: 1
        });
      };
    }
  });

  return (
    <div {...getRootProps()} className="border-2 border-dashed p-6">
      <input {...getInputProps()} />
      <p>Glissez votre logo ici ou cliquez</p>
      <p className="text-sm text-gray-500">PNG, JPG, SVG - Max 2MB</p>
    </div>
  );
};

// Utilitaire compression
async function compressImage(file: File): Promise<File> {
  return new Promise((resolve) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;

    img.onload = () => {
      // Redimensionner si trop grand
      let { width, height } = img;
      const maxDimension = 1024;
      
      if (width > maxDimension || height > maxDimension) {
        if (width > height) {
          height = (height / width) * maxDimension;
          width = maxDimension;
        } else {
          width = (width / height) * maxDimension;
          height = maxDimension;
        }
      }

      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(new File([blob!], file.name, { type: 'image/jpeg' }));
      }, 'image/jpeg', 0.85);
    };

    img.src = URL.createObjectURL(file);
  });
}
```

**2. Outil Texte**:
```typescript
// components/atelier/TextTool.tsx
const TextTool = ({ onAddText }) => {
  const [text, setText] = useState('');
  const [fontFamily, setFontFamily] = useState('Arial');
  const [fontSize, setFontSize] = useState(48);
  const [color, setColor] = useState('#000000');
  const [isBold, setIsBold] = useState(false);
  const [isItalic, setIsItalic] = useState(false);

  const fonts = [
    'Arial', 'Helvetica', 'Times New Roman', 'Courier New',
    'Georgia', 'Verdana', 'Comic Sans MS', 'Impact',
    'Montserrat', 'Roboto', 'Open Sans', 'Lato'
  ];

  const handleAddText = () => {
    if (!text.trim()) return;

    const textElement: DesignElement = {
      id: generateId(),
      type: 'text',
      text: text,
      fontFamily: fontFamily,
      fontSize: fontSize,
      color: color,
      fontWeight: isBold ? 'bold' : 'normal',
      fontStyle: isItalic ? 'italic' : 'normal',
      position: { x: 512, y: 512 }, // Centre du canvas 1024x1024
      rotation: 0,
      opacity: 1
    };

    onAddText(textElement);
    setText('');
  };

  return (
    <div className="space-y-4 p-4">
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Entrez votre texte..."
        className="w-full p-2 border rounded"
      />

      <select
        value={fontFamily}
        onChange={(e) => setFontFamily(e.target.value)}
        className="w-full p-2 border rounded"
      >
        {fonts.map(font => (
          <option key={font} value={font}>{font}</option>
        ))}
      </select>

      <div className="flex gap-2">
        <label className="flex-1">
          Taille
          <input
            type="range"
            min="12"
            max="200"
            value={fontSize}
            onChange={(e) => setFontSize(Number(e.target.value))}
            className="w-full"
          />